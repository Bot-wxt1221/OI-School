# A 学飞机

## 题意

共有 $n$ 个模块，第 $i$ 个模块分别有参数 $r_{i,j}$ 和 $u_{i,j}$，其中 $j \in [1,m]$。

最开始有 $m$ 个数 $p_i$ 。初始均为 $0$。

你可以每次操作选择某个模块进行学习，要求当前的 $\forall\ j \in [1,m],r_{i,j} \leq p_j$ ，学习完成之后 $p_j \gets p_j+u_{i,j}$ 。

请求出最多能学习多少个模块。

## 解法

观察到一旦学习一个模块后，不会使本来能够被学习的模块不能被学习，所以可以任意选择当前可学习模块直到没有模块可供学习。

具体实现可以记录每个模块有多少个主题仍然未满足，并在学习每个模块后更新每个主题的 $p_j$ 时维护该信息，对于每一个主题，将该主题所有模块的 $r_{i,j}$ 进行排序用一个指针从头到尾扫描整个数组的方式可保证时间复杂度。

时间复杂度：$\mathcal {O} (nk\log n)$

# B 造飞机

## 题意

给定若干区间 $[l_i,r_i]$，生成一个序列 $A$。

序列最开始为空。

遍历每个区间 $[l_i,r_i]$ ，向序列中按顺序插入 $[l_i,r_i]$ 中的元素。

最终给定若干询问 $s_i$ 。

求出：

$$
\sum_{i=1}^ {n} \sum _{j=i+1}^{n} [A_i=A_j] \times [s \leq j-i]
$$

## 解法

答案可能很大，我们考虑如何快速统计。

可以发现任意两个区间对答案的影响实际上是可计算的。

具体来说，考虑这两个区间的重叠部分，你会发现因为放置区间的方式是从小到大，这两个区间中这些数的间隔实际上是相同的。

因此我们可以设计出一个算法：

最开始数轴上 $[1,n]$ 为空。

枚举区间，其覆盖了 $[l_i,r_i]$ 的区间，这段原有的区间与其重叠，均可对答案产生影响，暴力枚举计算即可，然后整个 $[l_i,r_i]$ 替换为一个完整的区间。

考虑这样做的时间复杂度为什么正确。

因为每次加入区间最坏情况是被原有的一个区间完整覆盖。

这样会增加 $2$ 个区间，然后我们发现每次操作若覆盖到了 $k (k>2)$ 个区间，区间数至少减少 $k-2$ 个，也就是说考虑 $k\leq 2$ 对时间复杂度贡献一定为 $\mathcal {O} (n)$ ，$k > 2$ 的情况下，因为总区间数为 $\mathcal {O} (n)$ ，时间复杂度也为 $\mathcal {O} (n)$ 。

采用 ODT 的方式实现，请注意该题时间复杂度不需要随机数据进行保证。

